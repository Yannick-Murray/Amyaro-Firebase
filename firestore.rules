rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions for security
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isValidUser() {
      // Require email verification for all operations (except initial user creation)
      return isAuthenticated() && request.auth.token.email_verified == true;
    }

    function isOwner(userId) {
      return isValidUser() && request.auth.uid == userId;
    }
    
    function isListOwner(listData) {
      return isValidUser() && request.auth.uid == listData.userId;
    }
    
    function hasListAccess(listData) {
      return isValidUser() && (
        request.auth.uid == listData.userId ||
        (listData.sharedWith != null && 
         request.auth.uid in listData.sharedWith)
      );
    }
    
    function hasPendingInvitationForList(listId) {
      return isValidUser() && 
             exists(/databases/$(database)/documents/listInvitations/$(listId + '_' + request.auth.uid)) ||
             exists(/databases/$(database)/documents/listInvitations/$(listId + '_' + request.auth.token.email));
    }
    
    function isValidString(text, minLen, maxLen) {
      return text is string && 
             text.size() >= minLen && 
             text.size() <= maxLen;
    }
    
    function isValidEmail(email) {
      return email is string && 
             email.matches('.*@.*\\..*') &&
             email.size() <= 254;
    }

    // Users collection
    match /users/{userId} {
      // Self-write: Allow users to create their own user document (during registration)
      // and update it later (only when email is verified OR during verification process)
      allow write: if isAuthenticated() && request.auth.uid == userId && (
        // During registration: allow creating user document even without email verification
        (resource == null) ||
        // After registration: require email verification for updates
        (resource != null && request.auth.token.email_verified == true) ||
        // Special case: Allow setting emailVerified field during verification process
        (resource != null && 
         request.resource.data.emailVerified == true &&
         (!('emailVerified' in resource.data) || resource.data.emailVerified == false))
      );
      
      // Self-read: Always allow users to read their own data (even if not verified)
      allow read: if isAuthenticated() && request.auth.uid == userId;
      
      // Other users: Allow reading basic info only if email verified
      allow read: if isValidUser() && request.auth.uid != userId;
    }

    // Lists collection - with proper validation
    match /lists/{listId} {
      allow read: if isValidUser() && hasListAccess(resource.data);
      
      // Special case: Allow single document read (get) for invitation acceptance
      // This allows reading a list document during invitation acceptance process
      allow get: if isValidUser() && request.auth.token.email != null;
      
      allow create: if isValidUser() && 
                       request.auth.uid == request.resource.data.userId &&
                       isValidString(request.resource.data.name, 1, 100) &&
                       request.resource.data.type in ['shopping', 'gift'] &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp;
      
      allow update: if isValidUser() && (
                       // List owner can update anything
                       isListOwner(resource.data) ||
                       // Shared users can update limited fields
                       (hasListAccess(resource.data) && 
                        request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['itemCount', 'updatedAt'])) ||
                       // Special case: Allow user to add themselves to sharedWith (invitation acceptance)
                       (request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['sharedWith', 'updatedAt']) &&
                        request.auth.uid in request.resource.data.sharedWith &&
                        (resource.data.sharedWith == null || !(request.auth.uid in resource.data.sharedWith)))
                     );
      
      allow delete: if isValidUser() && isListOwner(resource.data);
    }
    
    // Categories - secure with proper list access control
    match /categories/{categoryId} {
      // Only allow reading categories for lists the user has access to
      // This requires client-side filtering or list-specific queries
      allow read: if isValidUser();
      
      allow create: if isValidUser() && 
                       request.resource.data.userId == request.auth.uid &&
                       isValidString(request.resource.data.name, 1, 50) &&
                       request.resource.data.listId is string &&
                       isValidString(request.resource.data.color, 3, 20) &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp;
      
      allow update: if isValidUser() &&
                       // Only category creator or list owner can update
                       (request.auth.uid == resource.data.userId) &&
                       request.resource.data.listId == resource.data.listId &&
                       (!('name' in request.resource.data) || 
                        isValidString(request.resource.data.name, 1, 50)) &&
                       (!('color' in request.resource.data) || 
                        isValidString(request.resource.data.color, 3, 20));
      
      allow delete: if isValidUser() &&
                       // Only category creator can delete
                       request.auth.uid == resource.data.userId;
    }
    
    // Items - secure with proper access control
    match /items/{itemId} {
      // Only allow reading items for lists the user has access to
      // This requires client-side filtering or list-specific queries
      allow read: if isValidUser();
      
      allow create: if isValidUser() && 
                       isValidString(request.resource.data.name, 1, 200) &&
                       request.resource.data.listId is string &&
                       request.resource.data.quantity is number &&
                       request.resource.data.quantity >= 1 &&
                       request.resource.data.quantity <= 99 &&
                       request.resource.data.isCompleted is bool &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp &&
                       // Optional categoryId validation
                       (!('categoryId' in request.resource.data) || 
                        request.resource.data.categoryId is string ||
                        request.resource.data.categoryId == null) &&
                       (!('order' in request.resource.data) || 
                        request.resource.data.order is number);
      
      allow update: if isValidUser() &&
                       // Validate updated fields
                       (!('name' in request.resource.data) || 
                        isValidString(request.resource.data.name, 1, 200)) &&
                       (!('quantity' in request.resource.data) || 
                        (request.resource.data.quantity is number &&
                         request.resource.data.quantity >= 1 &&
                         request.resource.data.quantity <= 99)) &&
                       (!('isCompleted' in request.resource.data) || 
                        request.resource.data.isCompleted is bool) &&
                       // Can't change listId
                       request.resource.data.listId == resource.data.listId;
      
      allow delete: if isValidUser();
    }
    
    // List invitations - secure handling (PRODUCTION READY)
    match /listInvitations/{invitationId} {
      // Read access: invitation sender, recipient by ID, or recipient by email
      allow read: if isValidUser() && (
        request.auth.uid == resource.data.fromUserId ||
        (resource.data.toUserId != null && 
         request.auth.uid == resource.data.toUserId) ||
        (resource.data.toEmail != null && 
         request.auth.token.email == resource.data.toEmail)
      );
      
      // List operation: Allow reading for checking existing invitations
      // This is needed for the sendInvitation function to check duplicates
      allow list: if isValidUser();
      
      allow create: if isValidUser() && 
                       request.auth.uid == request.resource.data.fromUserId &&
                       isValidString(request.resource.data.listName, 1, 100) &&
                       isValidString(request.resource.data.fromUserName, 1, 100) &&
                       isValidEmail(request.resource.data.toEmail) &&
                       request.resource.data.permission in ['read', 'write'] &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.createdAt is timestamp &&
                       // Optional fields validation
                       (!('expiresAt' in request.resource.data) || 
                        request.resource.data.expiresAt is timestamp) &&
                       (!('toUserId' in request.resource.data) || 
                        request.resource.data.toUserId is string) &&
                       (!('listId' in request.resource.data) || 
                        request.resource.data.listId is string);
      
      allow update: if isValidUser() && (
        ((resource.data.toUserId != null && 
          request.auth.uid == resource.data.toUserId) ||
         (resource.data.toEmail != null && 
          request.auth.token.email == resource.data.toEmail)) &&
        request.resource.data.status in ['accepted', 'declined', 'expired'] &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['status', 'respondedAt', 'toUserId'])
      );
      
      allow delete: if isValidUser() && 
                       request.auth.uid == resource.data.fromUserId;
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}