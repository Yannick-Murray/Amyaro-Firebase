rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions for security
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isValidUser() {
      // Require email verification for all operations (except initial user creation)
      return isAuthenticated() && request.auth.token.email_verified == true;
    }

    function isOwner(userId) {
      return isValidUser() && request.auth.uid == userId;
    }
    
    function isListOwner(listData) {
      return isValidUser() && request.auth.uid == listData.userId;
    }
    
    function hasListAccess(listData) {
      return isValidUser() && (
        request.auth.uid == listData.userId ||
        (listData.sharedWith != null && 
         request.auth.uid in listData.sharedWith)
      );
    }
    
    function hasPendingInvitationForList(listId) {
      return isValidUser() && 
             exists(/databases/$(database)/documents/listInvitations/$(listId + '_' + request.auth.uid)) ||
             exists(/databases/$(database)/documents/listInvitations/$(listId + '_' + request.auth.token.email));
    }
    
    function isValidString(text, minLen, maxLen) {
      return text is string && 
             text.size() >= minLen && 
             text.size() <= maxLen;
    }
    
    function isWithinRateLimit() {
      // Rate limiting: Max 5 invitations per user per hour
      let now = request.time;
      let oneHourAgo = timestamp.value(now.toMillis() - 3600000); // 1 hour in milliseconds
      
      // This is a simplified check - in production you'd need a more sophisticated approach
      // involving aggregation queries or Cloud Functions for complex rate limiting
      return request.resource.data.createdAt is timestamp;
    }
    
    function isValidEmail(email) {
      return email is string && 
             email.matches('.*@.*\\..*') &&
             email.size() <= 254;
    }

    // Users collection
    match /users/{userId} {
      // Self-write: Allow users to create their own user document (during registration)
      // and update it later (only when email is verified OR during verification process)
      allow write: if isAuthenticated() && request.auth.uid == userId && (
        // During registration: allow creating user document even without email verification
        (resource == null) ||
        // After registration: require email verification for updates
        (resource != null && request.auth.token.email_verified == true) ||
        // Special case: Allow setting emailVerified field during verification process
        (resource != null && 
         request.resource.data.emailVerified == true &&
         (!('emailVerified' in resource.data) || resource.data.emailVerified == false))
      );
      
      // Self-read: Always allow users to read their own data (even if not verified)
      allow read: if isAuthenticated() && request.auth.uid == userId;
      
      // Other users: Allow reading basic info only if email verified
      allow read: if isValidUser() && request.auth.uid != userId;
    }

    // Lists collection - with proper validation
    match /lists/{listId} {
      allow read: if isValidUser() && hasListAccess(resource.data);
      
      // Special case: Allow single document read (get) for invitation acceptance
      // This allows reading a list document during invitation acceptance process
      allow get: if isValidUser() && request.auth.token.email != null;
      
      allow create: if isValidUser() && 
                       request.auth.uid == request.resource.data.userId &&
                       isValidString(request.resource.data.name, 1, 100) &&
                       request.resource.data.type in ['shopping', 'gift'] &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp;
      
      allow update: if isValidUser() && (
                       // List owner can update anything
                       isListOwner(resource.data) ||
                       // Shared users can update limited fields
                       (hasListAccess(resource.data) && 
                        request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['itemCount', 'updatedAt'])) ||
                       // Special case: Allow user to add themselves to sharedWith (invitation acceptance)
                       (request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['sharedWith', 'updatedAt']) &&
                        request.auth.uid in request.resource.data.sharedWith &&
                        (resource.data.sharedWith == null || !(request.auth.uid in resource.data.sharedWith)))
                     );
      
      allow delete: if isValidUser() && isListOwner(resource.data);
    }
    
    // Categories - secure with proper list access control
    match /categories/{categoryId} {
      // Only allow reading categories for lists the user has access to
      // Must check if user has access to the associated list
      allow read: if isValidUser() && 
                     exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                     hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
      
      allow create: if isValidUser() && 
                       request.resource.data.userId == request.auth.uid &&
                       isValidString(request.resource.data.name, 1, 50) &&
                       request.resource.data.listId is string &&
                       isValidString(request.resource.data.color, 3, 20) &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp &&
                       // User must have access to the target list
                       exists(/databases/$(database)/documents/lists/$(request.resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(request.resource.data.listId)).data);
      
      allow update: if isValidUser() &&
                       request.resource.data.listId == resource.data.listId &&
                       (!('name' in request.resource.data) || 
                        isValidString(request.resource.data.name, 1, 50)) &&
                       (!('color' in request.resource.data) || 
                        isValidString(request.resource.data.color, 3, 20)) &&
                       (!('order' in request.resource.data) || 
                        request.resource.data.order is number) &&
                       // User must have access to the associated list
                       exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data) &&
                       // Either category creator OR anyone with list access for order-only changes
                       (request.auth.uid == resource.data.userId ||
                        request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['order', 'updatedAt']));
      
      allow delete: if isValidUser() &&
                       // Anyone with list access can delete categories
                       exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
    }
    
    // Items - secure with proper access control
    match /items/{itemId} {
      // Only allow reading items for lists the user has access to
      // Must check if user has access to the associated list
      allow read: if isValidUser() && 
                     exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                     hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
      
      allow create: if isValidUser() && 
                       isValidString(request.resource.data.name, 1, 200) &&
                       request.resource.data.listId is string &&
                       request.resource.data.quantity is number &&
                       request.resource.data.quantity >= 1 &&
                       request.resource.data.quantity <= 99 &&
                       request.resource.data.isCompleted is bool &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp &&
                       // Optional categoryId validation
                       (!('categoryId' in request.resource.data) || 
                        request.resource.data.categoryId is string ||
                        request.resource.data.categoryId == null) &&
                       (!('order' in request.resource.data) || 
                        request.resource.data.order is number) &&
                       // User must have access to the target list
                       exists(/databases/$(database)/documents/lists/$(request.resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(request.resource.data.listId)).data);
      
      allow update: if isValidUser() &&
                       // Validate updated fields
                       (!('name' in request.resource.data) || 
                        isValidString(request.resource.data.name, 1, 200)) &&
                       (!('quantity' in request.resource.data) || 
                        (request.resource.data.quantity is number &&
                         request.resource.data.quantity >= 1 &&
                         request.resource.data.quantity <= 99)) &&
                       (!('isCompleted' in request.resource.data) || 
                        request.resource.data.isCompleted is bool) &&
                       // Can't change listId
                       request.resource.data.listId == resource.data.listId &&
                       // User must have access to the associated list
                       exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
      
      allow delete: if isValidUser() &&
                       // User must have access to the associated list
                       exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
    }
    
    // TodoItems - secure with proper access control (newer schema)
    match /todoItems/{itemId} {
      // Only allow reading items for lists the user has access to
      // Must check if user has access to the associated list
      allow read: if isValidUser() && 
                     exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                     hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
      
      allow create: if isValidUser() && 
                       isValidString(request.resource.data.name, 1, 200) &&
                       request.resource.data.listId is string &&
                       request.resource.data.quantity is number &&
                       request.resource.data.quantity >= 1 &&
                       request.resource.data.quantity <= 99 &&
                       request.resource.data.isCompleted is bool &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp &&
                       // Optional categoryId validation
                       (!('categoryId' in request.resource.data) || 
                        request.resource.data.categoryId is string ||
                        request.resource.data.categoryId == null) &&
                       (!('order' in request.resource.data) || 
                        request.resource.data.order is number) &&
                       // User must have access to the target list
                       exists(/databases/$(database)/documents/lists/$(request.resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(request.resource.data.listId)).data);
      
      allow update: if isValidUser() &&
                       // Validate updated fields
                       (!('name' in request.resource.data) || 
                        isValidString(request.resource.data.name, 1, 200)) &&
                       (!('quantity' in request.resource.data) || 
                        (request.resource.data.quantity is number &&
                         request.resource.data.quantity >= 1 &&
                         request.resource.data.quantity <= 99)) &&
                       (!('isCompleted' in request.resource.data) || 
                        request.resource.data.isCompleted is bool) &&
                       // Can't change listId
                       request.resource.data.listId == resource.data.listId &&
                       // User must have access to the associated list
                       exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
      
      allow delete: if isValidUser() &&
                       // User must have access to the associated list
                       exists(/databases/$(database)/documents/lists/$(resource.data.listId)) &&
                       hasListAccess(get(/databases/$(database)/documents/lists/$(resource.data.listId)).data);
    }
    
    // List invitations - secure handling (PRODUCTION READY)
    match /listInvitations/{invitationId} {
      // Read access: invitation sender, recipient by ID, or recipient by email
      allow read: if isValidUser() && (
        request.auth.uid == resource.data.fromUserId ||
        (resource.data.toUserId != null && 
         request.auth.uid == resource.data.toUserId) ||
        (resource.data.toEmail != null && 
         request.auth.token.email == resource.data.toEmail)
      );
      
      // List operation: Allow reading for checking existing invitations
      // This is needed for the sendInvitation function to check duplicates
      allow list: if isValidUser();
      
      allow create: if isValidUser() && 
                       request.auth.uid == request.resource.data.fromUserId &&
                       isValidString(request.resource.data.listName, 1, 100) &&
                       isValidString(request.resource.data.fromUserName, 1, 100) &&
                       isValidEmail(request.resource.data.toEmail) &&
                       request.resource.data.permission in ['read', 'write'] &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.createdAt is timestamp &&
                       // Rate limiting: Basic validation (complex rate limiting needs Cloud Functions)
                       isWithinRateLimit() &&
                       // Optional fields validation
                       (!('expiresAt' in request.resource.data) || 
                        request.resource.data.expiresAt is timestamp) &&
                       (!('toUserId' in request.resource.data) || 
                        request.resource.data.toUserId is string) &&
                       (!('listId' in request.resource.data) || 
                        request.resource.data.listId is string);
      
      allow update: if isValidUser() && (
        ((resource.data.toUserId != null && 
          request.auth.uid == resource.data.toUserId) ||
         (resource.data.toEmail != null && 
          request.auth.token.email == resource.data.toEmail)) &&
        request.resource.data.status in ['accepted', 'declined', 'expired'] &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['status', 'respondedAt', 'toUserId'])
      );
      
      allow delete: if isValidUser() && 
                       request.auth.uid == resource.data.fromUserId;
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}